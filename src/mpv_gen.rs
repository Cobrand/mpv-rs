/* automatically generated by rust-bindgen 0.68.1 */
/* automatically generated by rust-bindgen 0.68.1 */
/*
- Run this command from the project root
    bindgen \
        --raw-line '#![allow(dead_code)]' \
        --raw-line '#![allow(non_snake_case)]' \
        --raw-line '#![allow(non_camel_case_types)]' \
        --raw-line '#![allow(non_upper_case_globals)]' \
        --rustified-enum '.*' \
        --no-layout-tests \
        --merge-extern-blocks \
        -o src/mpv_gen.rs \
        /usr/include/mpv/render_gl.h
- Wrap all enums in enum_from_primitive! { ... }
- Add `#[link(name = "mpv")]` to extern block
*/

#![allow(dead_code)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 37;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const MPV_ENABLE_DEPRECATED: u32 = 1;
pub const MPV_RENDER_API_TYPE_OPENGL: &[u8; 7] = b"opengl\0";
pub const MPV_RENDER_API_TYPE_SW: &[u8; 3] = b"sw\0";
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __max_align_ll: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __max_align_ld: u128,
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpv_handle {
    _unused: [u8; 0],
}
enum_from_primitive! {
#[repr(i32)]
#[doc = " List of error codes than can be returned by API functions. 0 and positive\n return values always mean success, negative values are always errors."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum mpv_error {
    #[doc = " No error happened (used to signal successful operation).\n Keep in mind that many API functions returning error codes can also\n return positive values, which also indicate success. API users can\n hardcode the fact that \">= 0\" means success."]
    MPV_ERROR_SUCCESS = 0,
    #[doc = " The event ringbuffer is full. This means the client is choked, and can't\n receive any events. This can happen when too many asynchronous requests\n have been made, but not answered. Probably never happens in practice,\n unless the mpv core is frozen for some reason, and the client keeps\n making asynchronous requests. (Bugs in the client API implementation\n could also trigger this, e.g. if events become \"lost\".)"]
    MPV_ERROR_EVENT_QUEUE_FULL = -1,
    #[doc = " Memory allocation failed."]
    MPV_ERROR_NOMEM = -2,
    #[doc = " The mpv core wasn't configured and initialized yet. See the notes in\n mpv_create()."]
    MPV_ERROR_UNINITIALIZED = -3,
    #[doc = " Generic catch-all error if a parameter is set to an invalid or\n unsupported value. This is used if there is no better error code."]
    MPV_ERROR_INVALID_PARAMETER = -4,
    #[doc = " Trying to set an option that doesn't exist."]
    MPV_ERROR_OPTION_NOT_FOUND = -5,
    #[doc = " Trying to set an option using an unsupported MPV_FORMAT."]
    MPV_ERROR_OPTION_FORMAT = -6,
    #[doc = " Setting the option failed. Typically this happens if the provided option\n value could not be parsed."]
    MPV_ERROR_OPTION_ERROR = -7,
    #[doc = " The accessed property doesn't exist."]
    MPV_ERROR_PROPERTY_NOT_FOUND = -8,
    #[doc = " Trying to set or get a property using an unsupported MPV_FORMAT."]
    MPV_ERROR_PROPERTY_FORMAT = -9,
    #[doc = " The property exists, but is not available. This usually happens when the\n associated subsystem is not active, e.g. querying audio parameters while\n audio is disabled."]
    MPV_ERROR_PROPERTY_UNAVAILABLE = -10,
    #[doc = " Error setting or getting a property."]
    MPV_ERROR_PROPERTY_ERROR = -11,
    #[doc = " General error when running a command with mpv_command and similar."]
    MPV_ERROR_COMMAND = -12,
    #[doc = " Generic error on loading (usually used with mpv_event_end_file.error)."]
    MPV_ERROR_LOADING_FAILED = -13,
    #[doc = " Initializing the audio output failed."]
    MPV_ERROR_AO_INIT_FAILED = -14,
    #[doc = " Initializing the video output failed."]
    MPV_ERROR_VO_INIT_FAILED = -15,
    #[doc = " There was no audio or video data to play. This also happens if the\n file was recognized, but did not contain any audio or video streams,\n or no streams were selected."]
    MPV_ERROR_NOTHING_TO_PLAY = -16,
    #[doc = " When trying to load the file, the file format could not be determined,\n or the file was too broken to open it."]
    MPV_ERROR_UNKNOWN_FORMAT = -17,
    #[doc = " Generic error for signaling that certain system requirements are not\n fulfilled."]
    MPV_ERROR_UNSUPPORTED = -18,
    #[doc = " The API function which was called is a stub only."]
    MPV_ERROR_NOT_IMPLEMENTED = -19,
    #[doc = " Unspecified error."]
    MPV_ERROR_GENERIC = -20,
}
}
enum_from_primitive! {
#[repr(u32)]
#[doc = " Data format for options and properties. The API functions to get/set\n properties and options support multiple formats, and this enum describes\n them."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum mpv_format {
    #[doc = " Invalid. Sometimes used for empty values. This is always defined to 0,\n so a normal 0-init of mpv_format (or e.g. mpv_node) is guaranteed to set\n this it to MPV_FORMAT_NONE (which makes some things saner as consequence)."]
    MPV_FORMAT_NONE = 0,
    #[doc = " The basic type is char*. It returns the raw property string, like\n using ${=property} in input.conf (see input.rst).\n\n NULL isn't an allowed value.\n\n Warning: although the encoding is usually UTF-8, this is not always the\n          case. File tags often store strings in some legacy codepage,\n          and even filenames don't necessarily have to be in UTF-8 (at\n          least on Linux). If you pass the strings to code that requires\n          valid UTF-8, you have to sanitize it in some way.\n          On Windows, filenames are always UTF-8, and libmpv converts\n          between UTF-8 and UTF-16 when using win32 API functions. See\n          the \"Encoding of filenames\" section for details.\n\n Example for reading:\n\n     char *result = NULL;\n     if (mpv_get_property(ctx, \"property\", MPV_FORMAT_STRING, &result) < 0)\n         goto error;\n     printf(\"%s\\n\", result);\n     mpv_free(result);\n\n Or just use mpv_get_property_string().\n\n Example for writing:\n\n     char *value = \"the new value\";\n     // yep, you pass the address to the variable\n     // (needed for symmetry with other types and mpv_get_property)\n     mpv_set_property(ctx, \"property\", MPV_FORMAT_STRING, &value);\n\n Or just use mpv_set_property_string().\n"]
    MPV_FORMAT_STRING = 1,
    #[doc = " The basic type is char*. It returns the OSD property string, like\n using ${property} in input.conf (see input.rst). In many cases, this\n is the same as the raw string, but in other cases it's formatted for\n display on OSD. It's intended to be human readable. Do not attempt to\n parse these strings.\n\n Only valid when doing read access. The rest works like MPV_FORMAT_STRING."]
    MPV_FORMAT_OSD_STRING = 2,
    #[doc = " The basic type is int. The only allowed values are 0 (\"no\")\n and 1 (\"yes\").\n\n Example for reading:\n\n     int result;\n     if (mpv_get_property(ctx, \"property\", MPV_FORMAT_FLAG, &result) < 0)\n         goto error;\n     printf(\"%s\\n\", result ? \"true\" : \"false\");\n\n Example for writing:\n\n     int flag = 1;\n     mpv_set_property(ctx, \"property\", MPV_FORMAT_FLAG, &flag);"]
    MPV_FORMAT_FLAG = 3,
    #[doc = " The basic type is int64_t."]
    MPV_FORMAT_INT64 = 4,
    #[doc = " The basic type is double."]
    MPV_FORMAT_DOUBLE = 5,
    #[doc = " The type is mpv_node.\n\n For reading, you usually would pass a pointer to a stack-allocated\n mpv_node value to mpv, and when you're done you call\n mpv_free_node_contents(&node).\n You're expected not to write to the data - if you have to, copy it\n first (which you have to do manually).\n\n For writing, you construct your own mpv_node, and pass a pointer to the\n API. The API will never write to your data (and copy it if needed), so\n you're free to use any form of allocation or memory management you like.\n\n Warning: when reading, always check the mpv_node.format member. For\n          example, properties might change their type in future versions\n          of mpv, or sometimes even during runtime.\n\n Example for reading:\n\n     mpv_node result;\n     if (mpv_get_property(ctx, \"property\", MPV_FORMAT_NODE, &result) < 0)\n         goto error;\n     printf(\"format=%d\\n\", (int)result.format);\n     mpv_free_node_contents(&result).\n\n Example for writing:\n\n     mpv_node value;\n     value.format = MPV_FORMAT_STRING;\n     value.u.string = \"hello\";\n     mpv_set_property(ctx, \"property\", MPV_FORMAT_NODE, &value);"]
    MPV_FORMAT_NODE = 6,
    #[doc = " Used with mpv_node only. Can usually not be used directly."]
    MPV_FORMAT_NODE_ARRAY = 7,
    #[doc = " See MPV_FORMAT_NODE_ARRAY."]
    MPV_FORMAT_NODE_MAP = 8,
    #[doc = " A raw, untyped byte array. Only used only with mpv_node, and only in\n some very specific situations. (Some commands use it.)"]
    MPV_FORMAT_BYTE_ARRAY = 9,
}
}
#[doc = " Generic data storage.\n\n If mpv writes this struct (e.g. via mpv_get_property()), you must not change\n the data. In some cases (mpv_get_property()), you have to free it with\n mpv_free_node_contents(). If you fill this struct yourself, you're also\n responsible for freeing it, and you must not call mpv_free_node_contents()."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mpv_node {
    pub u: mpv_node__bindgen_ty_1,
    #[doc = " Type of the data stored in this struct. This value rules what members in\n the given union can be accessed. The following formats are currently\n defined to be allowed in mpv_node:\n\n  MPV_FORMAT_STRING       (u.string)\n  MPV_FORMAT_FLAG         (u.flag)\n  MPV_FORMAT_INT64        (u.int64)\n  MPV_FORMAT_DOUBLE       (u.double_)\n  MPV_FORMAT_NODE_ARRAY   (u.list)\n  MPV_FORMAT_NODE_MAP     (u.list)\n  MPV_FORMAT_BYTE_ARRAY   (u.ba)\n  MPV_FORMAT_NONE         (no member)\n\n If you encounter a value you don't know, you must not make any\n assumptions about the contents of union u."]
    pub format: mpv_format,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mpv_node__bindgen_ty_1 {
    pub string: *mut ::std::os::raw::c_char,
    #[doc = " valid if format==MPV_FORMAT_STRING"]
    pub flag: ::std::os::raw::c_int,
    #[doc = " valid if format==MPV_FORMAT_FLAG"]
    pub int64: i64,
    #[doc = " valid if format==MPV_FORMAT_INT64"]
    pub double_: f64,
    #[doc = " valid if format==MPV_FORMAT_DOUBLE */\n/**\n valid if format==MPV_FORMAT_NODE_ARRAY\n    or if format==MPV_FORMAT_NODE_MAP"]
    pub list: *mut mpv_node_list,
    #[doc = " valid if format==MPV_FORMAT_BYTE_ARRAY"]
    pub ba: *mut mpv_byte_array,
}
#[doc = " (see mpv_node)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpv_node_list {
    #[doc = " Number of entries. Negative values are not allowed."]
    pub num: ::std::os::raw::c_int,
    #[doc = " MPV_FORMAT_NODE_ARRAY:\n  values[N] refers to value of the Nth item\n\n MPV_FORMAT_NODE_MAP:\n  values[N] refers to value of the Nth key/value pair\n\n If num > 0, values[0] to values[num-1] (inclusive) are valid.\n Otherwise, this can be NULL."]
    pub values: *mut mpv_node,
    #[doc = " MPV_FORMAT_NODE_ARRAY:\n  unused (typically NULL), access is not allowed\n\n MPV_FORMAT_NODE_MAP:\n  keys[N] refers to key of the Nth key/value pair. If num > 0, keys[0] to\n  keys[num-1] (inclusive) are valid. Otherwise, this can be NULL.\n  The keys are in random order. The only guarantee is that keys[N] belongs\n  to the value values[N]. NULL keys are not allowed."]
    pub keys: *mut *mut ::std::os::raw::c_char,
}
#[doc = " (see mpv_node)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpv_byte_array {
    #[doc = " Pointer to the data. In what format the data is stored is up to whatever\n uses MPV_FORMAT_BYTE_ARRAY."]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = " Size of the data pointed to by ptr."]
    pub size: usize,
}
enum_from_primitive! {
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum mpv_event_id {
    #[doc = " Nothing happened. Happens on timeouts or sporadic wakeups."]
    MPV_EVENT_NONE = 0,
    #[doc = " Happens when the player quits. The player enters a state where it tries\n to disconnect all clients. Most requests to the player will fail, and\n the client should react to this and quit with mpv_destroy() as soon as\n possible."]
    MPV_EVENT_SHUTDOWN = 1,
    #[doc = " See mpv_request_log_messages()."]
    MPV_EVENT_LOG_MESSAGE = 2,
    #[doc = " Reply to a mpv_get_property_async() request.\n See also mpv_event and mpv_event_property."]
    MPV_EVENT_GET_PROPERTY_REPLY = 3,
    #[doc = " Reply to a mpv_set_property_async() request.\n (Unlike MPV_EVENT_GET_PROPERTY, mpv_event_property is not used.)"]
    MPV_EVENT_SET_PROPERTY_REPLY = 4,
    #[doc = " Reply to a mpv_command_async() or mpv_command_node_async() request.\n See also mpv_event and mpv_event_command."]
    MPV_EVENT_COMMAND_REPLY = 5,
    #[doc = " Notification before playback start of a file (before the file is loaded).\n See also mpv_event and mpv_event_start_file."]
    MPV_EVENT_START_FILE = 6,
    #[doc = " Notification after playback end (after the file was unloaded).\n See also mpv_event and mpv_event_end_file."]
    MPV_EVENT_END_FILE = 7,
    #[doc = " Notification when the file has been loaded (headers were read etc.), and\n decoding starts."]
    MPV_EVENT_FILE_LOADED = 8,
    #[doc = " Idle mode was entered. In this mode, no file is played, and the playback\n core waits for new commands. (The command line player normally quits\n instead of entering idle mode, unless --idle was specified. If mpv\n was started with mpv_create(), idle mode is enabled by default.)\n\n @deprecated This is equivalent to using mpv_observe_property() on the\n             \"idle-active\" property. The event is redundant, and might be\n             removed in the far future. As a further warning, this event\n             is not necessarily sent at the right point anymore (at the\n             start of the program), while the property behaves correctly."]
    MPV_EVENT_IDLE = 11,
    #[doc = " Sent every time after a video frame is displayed. Note that currently,\n this will be sent in lower frequency if there is no video, or playback\n is paused - but that will be removed in the future, and it will be\n restricted to video frames only.\n\n @deprecated Use mpv_observe_property() with relevant properties instead\n             (such as \"playback-time\")."]
    MPV_EVENT_TICK = 14,
    #[doc = " Triggered by the script-message input command. The command uses the\n first argument of the command as client name (see mpv_client_name()) to\n dispatch the message, and passes along all arguments starting from the\n second argument as strings.\n See also mpv_event and mpv_event_client_message."]
    MPV_EVENT_CLIENT_MESSAGE = 16,
    #[doc = " Happens after video changed in some way. This can happen on resolution\n changes, pixel format changes, or video filter changes. The event is\n sent after the video filters and the VO are reconfigured. Applications\n embedding a mpv window should listen to this event in order to resize\n the window if needed.\n Note that this event can happen sporadically, and you should check\n yourself whether the video parameters really changed before doing\n something expensive."]
    MPV_EVENT_VIDEO_RECONFIG = 17,
    #[doc = " Similar to MPV_EVENT_VIDEO_RECONFIG. This is relatively uninteresting,\n because there is no such thing as audio output embedding."]
    MPV_EVENT_AUDIO_RECONFIG = 18,
    #[doc = " Happens when a seek was initiated. Playback stops. Usually it will\n resume with MPV_EVENT_PLAYBACK_RESTART as soon as the seek is finished."]
    MPV_EVENT_SEEK = 20,
    #[doc = " There was a discontinuity of some sort (like a seek), and playback\n was reinitialized. Usually happens on start of playback and after\n seeking. The main purpose is allowing the client to detect when a seek\n request is finished."]
    MPV_EVENT_PLAYBACK_RESTART = 21,
    #[doc = " Event sent due to mpv_observe_property().\n See also mpv_event and mpv_event_property."]
    MPV_EVENT_PROPERTY_CHANGE = 22,
    #[doc = " Happens if the internal per-mpv_handle ringbuffer overflows, and at\n least 1 event had to be dropped. This can happen if the client doesn't\n read the event queue quickly enough with mpv_wait_event(), or if the\n client makes a very large number of asynchronous calls at once.\n\n Event delivery will continue normally once this event was returned\n (this forces the client to empty the queue completely)."]
    MPV_EVENT_QUEUE_OVERFLOW = 24,
    #[doc = " Triggered if a hook handler was registered with mpv_hook_add(), and the\n hook is invoked. If you receive this, you must handle it, and continue\n the hook with mpv_hook_continue().\n See also mpv_event and mpv_event_hook."]
    MPV_EVENT_HOOK = 25,
}
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpv_event_property {
    #[doc = " Name of the property."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Format of the data field in the same struct. See enum mpv_format.\n This is always the same format as the requested format, except when\n the property could not be retrieved (unavailable, or an error happened),\n in which case the format is MPV_FORMAT_NONE."]
    pub format: mpv_format,
    #[doc = " Received property value. Depends on the format. This is like the\n pointer argument passed to mpv_get_property().\n\n For example, for MPV_FORMAT_STRING you get the string with:\n\n    char *value = *(char **)(event_property->data);\n\n Note that this is set to NULL if retrieving the property failed (the\n format will be MPV_FORMAT_NONE)."]
    pub data: *mut ::std::os::raw::c_void,
}
enum_from_primitive! {
#[repr(u32)]
#[doc = " Numeric log levels. The lower the number, the more important the message is.\n MPV_LOG_LEVEL_NONE is never used when receiving messages. The string in\n the comment after the value is the name of the log level as used for the\n mpv_request_log_messages() function.\n Unused numeric values are unused, but reserved for future use."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum mpv_log_level {
    MPV_LOG_LEVEL_NONE = 0,
    #[doc = " \"no\"    - disable absolutely all messages"]
    MPV_LOG_LEVEL_FATAL = 10,
    #[doc = " \"fatal\" - critical/aborting errors"]
    MPV_LOG_LEVEL_ERROR = 20,
    #[doc = " \"error\" - simple errors"]
    MPV_LOG_LEVEL_WARN = 30,
    #[doc = " \"warn\"  - possible problems"]
    MPV_LOG_LEVEL_INFO = 40,
    #[doc = " \"info\"  - informational message"]
    MPV_LOG_LEVEL_V = 50,
    #[doc = " \"v\"     - noisy informational message"]
    MPV_LOG_LEVEL_DEBUG = 60,
    #[doc = " \"debug\" - very noisy technical information"]
    MPV_LOG_LEVEL_TRACE = 70,
}
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpv_event_log_message {
    #[doc = " The module prefix, identifies the sender of the message. As a special\n case, if the message buffer overflows, this will be set to the string\n \"overflow\" (which doesn't appear as prefix otherwise), and the text\n field will contain an informative message."]
    pub prefix: *const ::std::os::raw::c_char,
    #[doc = " The log level as string. See mpv_request_log_messages() for possible\n values. The level \"no\" is never used here."]
    pub level: *const ::std::os::raw::c_char,
    #[doc = " The log message. It consists of 1 line of text, and is terminated with\n a newline character. (Before API version 1.6, it could contain multiple\n or partial lines.)"]
    pub text: *const ::std::os::raw::c_char,
    #[doc = " The same contents as the level field, but as a numeric ID.\n Since API version 1.6."]
    pub log_level: mpv_log_level,
}
enum_from_primitive! {
#[repr(u32)]
#[doc = " Since API version 1.9."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum mpv_end_file_reason {
    #[doc = " The end of file was reached. Sometimes this may also happen on\n incomplete or corrupted files, or if the network connection was\n interrupted when playing a remote file. It also happens if the\n playback range was restricted with --end or --frames or similar."]
    MPV_END_FILE_REASON_EOF = 0,
    #[doc = " Playback was stopped by an external action (e.g. playlist controls)."]
    MPV_END_FILE_REASON_STOP = 2,
    #[doc = " Playback was stopped by the quit command or player shutdown."]
    MPV_END_FILE_REASON_QUIT = 3,
    #[doc = " Some kind of error happened that lead to playback abort. Does not\n necessarily happen on incomplete or broken files (in these cases, both\n MPV_END_FILE_REASON_ERROR or MPV_END_FILE_REASON_EOF are possible).\n\n mpv_event_end_file.error will be set."]
    MPV_END_FILE_REASON_ERROR = 4,
    #[doc = " The file was a playlist or similar. When the playlist is read, its\n entries will be appended to the playlist after the entry of the current\n file, the entry of the current file is removed, and a MPV_EVENT_END_FILE\n event is sent with reason set to MPV_END_FILE_REASON_REDIRECT. Then\n playback continues with the playlist contents.\n Since API version 1.18."]
    MPV_END_FILE_REASON_REDIRECT = 5,
}
}
#[doc = " Since API version 1.108."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpv_event_start_file {
    #[doc = " Playlist entry ID of the file being loaded now."]
    pub playlist_entry_id: i64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpv_event_end_file {
    #[doc = " Corresponds to the values in enum mpv_end_file_reason.\n\n Unknown values should be treated as unknown."]
    pub reason: mpv_end_file_reason,
    #[doc = " If reason==MPV_END_FILE_REASON_ERROR, this contains a mpv error code\n (one of MPV_ERROR_...) giving an approximate reason why playback\n failed. In other cases, this field is 0 (no error).\n Since API version 1.9."]
    pub error: ::std::os::raw::c_int,
    #[doc = " Playlist entry ID of the file that was being played or attempted to be\n played. This has the same value as the playlist_entry_id field in the\n corresponding mpv_event_start_file event.\n Since API version 1.108."]
    pub playlist_entry_id: i64,
    #[doc = " If loading ended, because the playlist entry to be played was for example\n a playlist, and the current playlist entry is replaced with a number of\n other entries. This may happen at least with MPV_END_FILE_REASON_REDIRECT\n (other event types may use this for similar but different purposes in the\n future). In this case, playlist_insert_id will be set to the playlist\n entry ID of the first inserted entry, and playlist_insert_num_entries to\n the total number of inserted playlist entries. Note this in this specific\n case, the ID of the last inserted entry is playlist_insert_id+num-1.\n Beware that depending on circumstances, you may observe the new playlist\n entries before seeing the event (e.g. reading the \"playlist\" property or\n getting a property change notification before receiving the event).\n Since API version 1.108."]
    pub playlist_insert_id: i64,
    #[doc = " See playlist_insert_id. Only non-0 if playlist_insert_id is valid. Never\n negative.\n Since API version 1.108."]
    pub playlist_insert_num_entries: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpv_event_client_message {
    #[doc = " Arbitrary arguments chosen by the sender of the message. If num_args > 0,\n you can access args[0] through args[num_args - 1] (inclusive). What\n these arguments mean is up to the sender and receiver.\n None of the valid items are NULL."]
    pub num_args: ::std::os::raw::c_int,
    pub args: *mut *const ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpv_event_hook {
    #[doc = " The hook name as passed to mpv_hook_add()."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Internal ID that must be passed to mpv_hook_continue()."]
    pub id: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mpv_event_command {
    #[doc = " Result data of the command. Note that success/failure is signaled\n separately via mpv_event.error. This field is only for result data\n in case of success. Most commands leave it at MPV_FORMAT_NONE. Set\n to MPV_FORMAT_NONE on failure."]
    pub result: mpv_node,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpv_event {
    #[doc = " One of mpv_event. Keep in mind that later ABI compatible releases might\n add new event types. These should be ignored by the API user."]
    pub event_id: mpv_event_id,
    #[doc = " This is mainly used for events that are replies to (asynchronous)\n requests. It contains a status code, which is >= 0 on success, or < 0\n on error (a mpv_error value). Usually, this will be set if an\n asynchronous request fails.\n Used for:\n  MPV_EVENT_GET_PROPERTY_REPLY\n  MPV_EVENT_SET_PROPERTY_REPLY\n  MPV_EVENT_COMMAND_REPLY"]
    pub error: ::std::os::raw::c_int,
    #[doc = " If the event is in reply to a request (made with this API and this\n API handle), this is set to the reply_userdata parameter of the request\n call. Otherwise, this field is 0.\n Used for:\n  MPV_EVENT_GET_PROPERTY_REPLY\n  MPV_EVENT_SET_PROPERTY_REPLY\n  MPV_EVENT_COMMAND_REPLY\n  MPV_EVENT_PROPERTY_CHANGE\n  MPV_EVENT_HOOK"]
    pub reply_userdata: u64,
    #[doc = " The meaning and contents of the data member depend on the event_id:\n  MPV_EVENT_GET_PROPERTY_REPLY:     mpv_event_property*\n  MPV_EVENT_PROPERTY_CHANGE:        mpv_event_property*\n  MPV_EVENT_LOG_MESSAGE:            mpv_event_log_message*\n  MPV_EVENT_CLIENT_MESSAGE:         mpv_event_client_message*\n  MPV_EVENT_START_FILE:             mpv_event_start_file* (since v1.108)\n  MPV_EVENT_END_FILE:               mpv_event_end_file*\n  MPV_EVENT_HOOK:                   mpv_event_hook*\n  MPV_EVENT_COMMAND_REPLY*          mpv_event_command*\n  other: NULL\n\n Note: future enhancements might add new event structs for existing or new\n       event types."]
    pub data: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpv_render_context {
    _unused: [u8; 0],
}
enum_from_primitive! {
#[repr(u32)]
#[doc = " Parameters for mpv_render_param (which is used in a few places such as\n mpv_render_context_create().\n\n Also see mpv_render_param for conventions and how to use it."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum mpv_render_param_type {
    #[doc = " Not a valid value, but also used to terminate a params array. Its value\n is always guaranteed to be 0 (even if the ABI changes in the future)."]
    MPV_RENDER_PARAM_INVALID = 0,
    #[doc = " The render API to use. Valid for mpv_render_context_create().\n\n Type: char*\n\n Defined APIs:\n\n   MPV_RENDER_API_TYPE_OPENGL:\n      OpenGL desktop 2.1 or later (preferably core profile compatible to\n      OpenGL 3.2), or OpenGLES 2.0 or later.\n      Providing MPV_RENDER_PARAM_OPENGL_INIT_PARAMS is required.\n      It is expected that an OpenGL context is valid and \"current\" when\n      calling mpv_render_* functions (unless specified otherwise). It\n      must be the same context for the same mpv_render_context."]
    MPV_RENDER_PARAM_API_TYPE = 1,
    #[doc = " Required parameters for initializing the OpenGL renderer. Valid for\n mpv_render_context_create().\n Type: mpv_opengl_init_params*"]
    MPV_RENDER_PARAM_OPENGL_INIT_PARAMS = 2,
    #[doc = " Describes a GL render target. Valid for mpv_render_context_render().\n Type: mpv_opengl_fbo*"]
    MPV_RENDER_PARAM_OPENGL_FBO = 3,
    #[doc = " Control flipped rendering. Valid for mpv_render_context_render().\n Type: int*\n If the value is set to 0, render normally. Otherwise, render it flipped,\n which is needed e.g. when rendering to an OpenGL default framebuffer\n (which has a flipped coordinate system)."]
    MPV_RENDER_PARAM_FLIP_Y = 4,
    #[doc = " Control surface depth. Valid for mpv_render_context_render().\n Type: int*\n This implies the depth of the surface passed to the render function in\n bits per channel. If omitted or set to 0, the renderer will assume 8.\n Typically used to control dithering."]
    MPV_RENDER_PARAM_DEPTH = 5,
    #[doc = " ICC profile blob. Valid for mpv_render_context_set_parameter().\n Type: mpv_byte_array*\n Set an ICC profile for use with the \"icc-profile-auto\" option. (If the\n option is not enabled, the ICC data will not be used.)"]
    MPV_RENDER_PARAM_ICC_PROFILE = 6,
    #[doc = " Ambient light in lux. Valid for mpv_render_context_set_parameter().\n Type: int*\n This can be used for automatic gamma correction."]
    MPV_RENDER_PARAM_AMBIENT_LIGHT = 7,
    #[doc = " X11 Display, sometimes used for hwdec. Valid for\n mpv_render_context_create(). The Display must stay valid for the lifetime\n of the mpv_render_context.\n Type: Display*"]
    MPV_RENDER_PARAM_X11_DISPLAY = 8,
    #[doc = " Wayland display, sometimes used for hwdec. Valid for\n mpv_render_context_create(). The wl_display must stay valid for the\n lifetime of the mpv_render_context.\n Type: struct wl_display*"]
    MPV_RENDER_PARAM_WL_DISPLAY = 9,
    #[doc = " Better control about rendering and enabling some advanced features. Valid\n for mpv_render_context_create().\n\n This conflates multiple requirements the API user promises to abide if\n this option is enabled:\n\n  - The API user's render thread, which is calling the mpv_render_*()\n    functions, never waits for the core. Otherwise deadlocks can happen.\n    See \"Threading\" section.\n  - The callback set with mpv_render_context_set_update_callback() can now\n    be called even if there is no new frame. The API user should call the\n    mpv_render_context_update() function, and interpret the return value\n    for whether a new frame should be rendered.\n  - Correct functionality is impossible if the update callback is not set,\n    or not set soon enough after mpv_render_context_create() (the core can\n    block while waiting for you to call mpv_render_context_update(), and\n    if the update callback is not correctly set, it will deadlock, or\n    block for too long).\n\n In general, setting this option will enable the following features (and\n possibly more):\n\n  - \"Direct rendering\", which means the player decodes directly to a\n    texture, which saves a copy per video frame (\"vd-lavc-dr\" option\n    needs to be enabled, and the rendering backend as well as the\n    underlying GPU API/driver needs to have support for it).\n  - Rendering screenshots with the GPU API if supported by the backend\n    (instead of using a suboptimal software fallback via libswscale).\n\n Warning: do not just add this without reading the \"Threading\" section\n          above, and then wondering that deadlocks happen. The\n          requirements are tricky. But also note that even if advanced\n          control is disabled, not adhering to the rules will lead to\n          playback problems. Enabling advanced controls simply makes\n          violating these rules fatal.\n\n Type: int*: 0 for disable (default), 1 for enable"]
    MPV_RENDER_PARAM_ADVANCED_CONTROL = 10,
    #[doc = " Return information about the next frame to render. Valid for\n mpv_render_context_get_info().\n\n Type: mpv_render_frame_info*\n\n It strictly returns information about the _next_ frame. The implication\n is that e.g. mpv_render_context_update()'s return value will have\n MPV_RENDER_UPDATE_FRAME set, and the user is supposed to call\n mpv_render_context_render(). If there is no next frame, then the\n return value will have is_valid set to 0."]
    MPV_RENDER_PARAM_NEXT_FRAME_INFO = 11,
    #[doc = " Enable or disable video timing. Valid for mpv_render_context_render().\n\n Type: int*: 0 for disable, 1 for enable (default)\n\n When video is timed to audio, the player attempts to render video a bit\n ahead, and then do a blocking wait until the target display time is\n reached. This blocks mpv_render_context_render() for up to the amount\n specified with the \"video-timing-offset\" global option. You can set\n this parameter to 0 to disable this kind of waiting. If you do, it's\n recommended to use the target time value in mpv_render_frame_info to\n wait yourself, or to set the \"video-timing-offset\" to 0 instead.\n\n Disabling this without doing anything in addition will result in A/V sync\n being slightly off."]
    MPV_RENDER_PARAM_BLOCK_FOR_TARGET_TIME = 12,
    #[doc = " Use to skip rendering in mpv_render_context_render().\n\n Type: int*: 0 for rendering (default), 1 for skipping\n\n If this is set, you don't need to pass a target surface to the render\n function (and if you do, it's completely ignored). This can still call\n into the lower level APIs (i.e. if you use OpenGL, the OpenGL context\n must be set).\n\n Be aware that the render API will consider this frame as having been\n rendered. All other normal rules also apply, for example about whether\n you have to call mpv_render_context_report_swap(). It also does timing\n in the same way."]
    MPV_RENDER_PARAM_SKIP_RENDERING = 13,
    #[doc = " Deprecated. Not supported. Use MPV_RENDER_PARAM_DRM_DISPLAY_V2 instead.\n Type : struct mpv_opengl_drm_params*"]
    MPV_RENDER_PARAM_DRM_DISPLAY = 14,
    #[doc = " DRM draw surface size, contains draw surface dimensions.\n Valid for mpv_render_context_create().\n Type : struct mpv_opengl_drm_draw_surface_size*"]
    MPV_RENDER_PARAM_DRM_DRAW_SURFACE_SIZE = 15,
    #[doc = " DRM display, contains drm display handles.\n Valid for mpv_render_context_create().\n Type : struct mpv_opengl_drm_params_v2*"]
    MPV_RENDER_PARAM_DRM_DISPLAY_V2 = 16,
    #[doc = " MPV_RENDER_API_TYPE_SW only: rendering target surface size, mandatory.\n Valid for MPV_RENDER_API_TYPE_SW & mpv_render_context_render().\n Type: int[2] (e.g.: int s[2] = {w, h}; param.data = &s[0];)\n\n The video frame is transformed as with other VOs. Typically, this means\n the video gets scaled and black bars are added if the video size or\n aspect ratio mismatches with the target size."]
    MPV_RENDER_PARAM_SW_SIZE = 17,
    #[doc = " MPV_RENDER_API_TYPE_SW only: rendering target surface pixel format,\n mandatory.\n Valid for MPV_RENDER_API_TYPE_SW & mpv_render_context_render().\n Type: char* (e.g.: char *f = \"rgb0\"; param.data = f;)\n\n Valid values are:\n  \"rgb0\", \"bgr0\", \"0bgr\", \"0rgb\"\n      4 bytes per pixel RGB, 1 byte (8 bit) per component, component bytes\n      with increasing address from left to right (e.g. \"rgb0\" has r at\n      address 0), the \"0\" component contains uninitialized garbage (often\n      the value 0, but not necessarily; the bad naming is inherited from\n      FFmpeg)\n      Pixel alignment size: 4 bytes\n  \"rgb24\"\n      3 bytes per pixel RGB. This is strongly discouraged because it is\n      very slow.\n      Pixel alignment size: 1 bytes\n  other\n      The API may accept other pixel formats, using mpv internal format\n      names, as long as it's internally marked as RGB, has exactly 1\n      plane, and is supported as conversion output. It is not a good idea\n      to rely on any of these. Their semantics and handling could change."]
    MPV_RENDER_PARAM_SW_FORMAT = 18,
    #[doc = " MPV_RENDER_API_TYPE_SW only: rendering target surface bytes per line,\n mandatory.\n Valid for MPV_RENDER_API_TYPE_SW & mpv_render_context_render().\n Type: size_t*\n\n This is the number of bytes between a pixel (x, y) and (x, y + 1) on the\n target surface. It must be a multiple of the pixel size, and have space\n for the surface width as specified by MPV_RENDER_PARAM_SW_SIZE.\n\n Both stride and pointer value should be a multiple of 64 to facilitate\n fast SIMD operation. Lower alignment might trigger slower code paths,\n and in the worst case, will copy the entire target frame. If mpv is built\n with zimg (and zimg is not disabled), the performance impact might be\n less.\n In either cases, the pointer and stride must be aligned at least to the\n pixel alignment size. Otherwise, crashes and undefined behavior is\n possible on platforms which do not support unaligned accesses (either\n through normal memory access or aligned SIMD memory access instructions)."]
    MPV_RENDER_PARAM_SW_STRIDE = 19,
    #[doc = " MPV_RENDER_API_TYPE_SW only: rendering target surface bytes per line,\n mandatory.\n Valid for MPV_RENDER_API_TYPE_SW & mpv_render_context_render().\n Type: size_t*\n\n This is the number of bytes between a pixel (x, y) and (x, y + 1) on the\n target surface. It must be a multiple of the pixel size, and have space\n for the surface width as specified by MPV_RENDER_PARAM_SW_SIZE.\n\n Both stride and pointer value should be a multiple of 64 to facilitate\n fast SIMD operation. Lower alignment might trigger slower code paths,\n and in the worst case, will copy the entire target frame. If mpv is built\n with zimg (and zimg is not disabled), the performance impact might be\n less.\n In either cases, the pointer and stride must be aligned at least to the\n pixel alignment size. Otherwise, crashes and undefined behavior is\n possible on platforms which do not support unaligned accesses (either\n through normal memory access or aligned SIMD memory access instructions)."]
    MPV_RENDER_PARAM_SW_POINTER = 20,
}
}
#[doc = " Used to pass arbitrary parameters to some mpv_render_* functions. The\n meaning of the data parameter is determined by the type, and each\n MPV_RENDER_PARAM_* documents what type the value must point to.\n\n Each value documents the required data type as the pointer you cast to\n void* and set on mpv_render_param.data. For example, if MPV_RENDER_PARAM_FOO\n documents the type as Something* , then the code should look like this:\n\n   Something foo = {...};\n   mpv_render_param param;\n   param.type = MPV_RENDER_PARAM_FOO;\n   param.data = & foo;\n\n Normally, the data field points to exactly 1 object. If the type is char*,\n it points to a 0-terminated string.\n\n In all cases (unless documented otherwise) the pointers need to remain\n valid during the call only. Unless otherwise documented, the API functions\n will not write to the params array or any data pointed to it.\n\n As a convention, parameter arrays are always terminated by type==0. There\n is no specific order of the parameters required. The order of the 2 fields in\n this struct is guaranteed (even after ABI changes)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpv_render_param {
    pub type_: mpv_render_param_type,
    pub data: *mut ::std::os::raw::c_void,
}
enum_from_primitive! {
#[repr(u32)]
#[doc = " Flags used in mpv_render_frame_info.flags. Each value represents a bit in it."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum mpv_render_frame_info_flag {
    #[doc = " Set if there is actually a next frame. If unset, there is no next frame\n yet, and other flags and fields that require a frame to be queued will\n be unset.\n\n This is set for _any_ kind of frame, even for redraw requests.\n\n Note that when this is unset, it simply means no new frame was\n decoded/queued yet, not necessarily that the end of the video was\n reached. A new frame can be queued after some time.\n\n If the return value of mpv_render_context_render() had the\n MPV_RENDER_UPDATE_FRAME flag set, this flag will usually be set as well,\n unless the frame is rendered, or discarded by other asynchronous events."]
    MPV_RENDER_FRAME_INFO_PRESENT = 1,
    #[doc = " If set, the frame is not an actual new video frame, but a redraw request.\n For example if the video is paused, and an option that affects video\n rendering was changed (or any other reason), an update request can be\n issued and this flag will be set.\n\n Typically, redraw frames will not be subject to video timing.\n\n Implies MPV_RENDER_FRAME_INFO_PRESENT."]
    MPV_RENDER_FRAME_INFO_REDRAW = 2,
    #[doc = " If set, this is supposed to reproduce the previous frame perfectly. This\n is usually used for certain \"video-sync\" options (\"display-...\" modes).\n Typically the renderer will blit the video from a FBO. Unset otherwise.\n\n Implies MPV_RENDER_FRAME_INFO_PRESENT."]
    MPV_RENDER_FRAME_INFO_REPEAT = 4,
    #[doc = " If set, the player timing code expects that the user thread blocks on\n vsync (by either delaying the render call, or by making a call to\n mpv_render_context_report_swap() at vsync time).\n\n Implies MPV_RENDER_FRAME_INFO_PRESENT."]
    MPV_RENDER_FRAME_INFO_BLOCK_VSYNC = 8,
}
}
#[doc = " Information about the next video frame that will be rendered. Can be\n retrieved with MPV_RENDER_PARAM_NEXT_FRAME_INFO."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpv_render_frame_info {
    #[doc = " A bitset of mpv_render_frame_info_flag values (i.e. multiple flags are\n combined with bitwise or)."]
    pub flags: u64,
    #[doc = " Absolute time at which the frame is supposed to be displayed. This is in\n the same unit and base as the time returned by mpv_get_time_us(). For\n frames that are redrawn, or if vsync locked video timing is used (see\n \"video-sync\" option), then this can be 0. The \"video-timing-offset\"\n option determines how much \"headroom\" the render thread gets (but a high\n enough frame rate can reduce it anyway). mpv_render_context_render() will\n normally block until the time is elapsed, unless you pass it\n MPV_RENDER_PARAM_BLOCK_FOR_TARGET_TIME = 0."]
    pub target_time: i64,
}
pub type mpv_render_update_fn =
    ::std::option::Option<unsafe extern "C" fn(cb_ctx: *mut ::std::os::raw::c_void)>;
    enum_from_primitive! {
#[repr(u32)]
#[doc = " Flags returned by mpv_render_context_update(). Each value represents a bit\n in the function's return value."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum mpv_render_update_flag {
    #[doc = " A new video frame must be rendered. mpv_render_context_render() must be\n called."]
    MPV_RENDER_UPDATE_FRAME = 1,
}
}
#[doc = " Flags returned by mpv_render_context_update(). Each value represents a bit\n in the function's return value."]
pub use self::mpv_render_update_flag as mpv_render_context_flag;
#[doc = " For initializing the mpv OpenGL state via MPV_RENDER_PARAM_OPENGL_INIT_PARAMS."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpv_opengl_init_params {
    #[doc = " This retrieves OpenGL function pointers, and will use them in subsequent\n operation.\n Usually, you can simply call the GL context APIs from this callback (e.g.\n glXGetProcAddressARB or wglGetProcAddress), but some APIs do not always\n return pointers for all standard functions (even if present); in this\n case you have to compensate by looking up these functions yourself when\n libmpv wants to resolve them through this callback.\n libmpv will not normally attempt to resolve GL functions on its own, nor\n does it link to GL libraries directly."]
    pub get_proc_address: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::std::os::raw::c_void,
            name: *const ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Value passed as ctx parameter to get_proc_address()."]
    pub get_proc_address_ctx: *mut ::std::os::raw::c_void,
}
#[doc = " For MPV_RENDER_PARAM_OPENGL_FBO."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpv_opengl_fbo {
    #[doc = " Framebuffer object name. This must be either a valid FBO generated by\n glGenFramebuffers() that is complete and color-renderable, or 0. If the\n value is 0, this refers to the OpenGL default framebuffer."]
    pub fbo: ::std::os::raw::c_int,
    #[doc = " Valid dimensions. This must refer to the size of the framebuffer. This\n must always be set."]
    pub w: ::std::os::raw::c_int,
    #[doc = " Valid dimensions. This must refer to the size of the framebuffer. This\n must always be set."]
    pub h: ::std::os::raw::c_int,
    #[doc = " Underlying texture internal format (e.g. GL_RGBA8), or 0 if unknown. If\n this is the default framebuffer, this can be an equivalent."]
    pub internal_format: ::std::os::raw::c_int,
}
#[doc = " Deprecated. For MPV_RENDER_PARAM_DRM_DISPLAY."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpv_opengl_drm_params {
    pub fd: ::std::os::raw::c_int,
    pub crtc_id: ::std::os::raw::c_int,
    pub connector_id: ::std::os::raw::c_int,
    pub atomic_request_ptr: *mut *mut _drmModeAtomicReq,
    pub render_fd: ::std::os::raw::c_int,
}
#[doc = " For MPV_RENDER_PARAM_DRM_DRAW_SURFACE_SIZE."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpv_opengl_drm_draw_surface_size {
    #[doc = " size of the draw plane surface in pixels."]
    pub width: ::std::os::raw::c_int,
    #[doc = " size of the draw plane surface in pixels."]
    pub height: ::std::os::raw::c_int,
}
#[doc = " For MPV_RENDER_PARAM_DRM_DISPLAY_V2."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpv_opengl_drm_params_v2 {
    #[doc = " DRM fd (int). Set to -1 if invalid."]
    pub fd: ::std::os::raw::c_int,
    #[doc = " Currently used crtc id"]
    pub crtc_id: ::std::os::raw::c_int,
    #[doc = " Currently used connector id"]
    pub connector_id: ::std::os::raw::c_int,
    #[doc = " Pointer to a drmModeAtomicReq pointer that is being used for the renderloop.\n This pointer should hold a pointer to the atomic request pointer\n The atomic request pointer is usually changed at every renderloop."]
    pub atomic_request_ptr: *mut *mut _drmModeAtomicReq,
    #[doc = " DRM render node. Used for VAAPI interop.\n Set to -1 if invalid."]
    pub render_fd: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _drmModeAtomicReq {
    pub _address: u8,
}
#[link(name = "mpv")]
extern "C" {
    #[doc = " Return the MPV_CLIENT_API_VERSION the mpv source has been compiled with."]
    pub fn mpv_client_api_version() -> ::std::os::raw::c_ulong;
    #[doc = " Return a string describing the error. For unknown errors, the string\n \"unknown error\" is returned.\n\n @param error error number, see enum mpv_error\n @return A static string describing the error. The string is completely\n         static, i.e. doesn't need to be deallocated, and is valid forever."]
    pub fn mpv_error_string(error: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
    #[doc = " General function to deallocate memory returned by some of the API functions.\n Call this only if it's explicitly documented as allowed. Calling this on\n mpv memory not owned by the caller will lead to undefined behavior.\n\n @param data A valid pointer returned by the API, or NULL."]
    pub fn mpv_free(data: *mut ::std::os::raw::c_void);
    #[doc = " Return the name of this client handle. Every client has its own unique\n name, which is mostly used for user interface purposes.\n\n @return The client name. The string is read-only and is valid until the\n         mpv_handle is destroyed."]
    pub fn mpv_client_name(ctx: *mut mpv_handle) -> *const ::std::os::raw::c_char;
    #[doc = " Return the ID of this client handle. Every client has its own unique ID. This\n ID is never reused by the core, even if the mpv_handle at hand gets destroyed\n and new handles get allocated.\n\n IDs are never 0 or negative.\n\n Some mpv APIs (not necessarily all) accept a name in the form \"@<id>\" in\n addition of the proper mpv_client_name(), where \"<id>\" is the ID in decimal\n form (e.g. \"@123\"). For example, the \"script-message-to\" command takes the\n client name as first argument, but also accepts the client ID formatted in\n this manner.\n\n @return The client ID."]
    pub fn mpv_client_id(ctx: *mut mpv_handle) -> i64;
    #[doc = " Create a new mpv instance and an associated client API handle to control\n the mpv instance. This instance is in a pre-initialized state,\n and needs to be initialized to be actually used with most other API\n functions.\n\n Some API functions will return MPV_ERROR_UNINITIALIZED in the uninitialized\n state. You can call mpv_set_property() (or mpv_set_property_string() and\n other variants, and before mpv 0.21.0 mpv_set_option() etc.) to set initial\n options. After this, call mpv_initialize() to start the player, and then use\n e.g. mpv_command() to start playback of a file.\n\n The point of separating handle creation and actual initialization is that\n you can configure things which can't be changed during runtime.\n\n Unlike the command line player, this will have initial settings suitable\n for embedding in applications. The following settings are different:\n - stdin/stdout/stderr and the terminal will never be accessed. This is\n   equivalent to setting the --no-terminal option.\n   (Technically, this also suppresses C signal handling.)\n - No config files will be loaded. This is roughly equivalent to using\n   --config=no. Since libmpv 1.15, you can actually re-enable this option,\n   which will make libmpv load config files during mpv_initialize(). If you\n   do this, you are strongly encouraged to set the \"config-dir\" option too.\n   (Otherwise it will load the mpv command line player's config.)\n   For example:\n      mpv_set_option_string(mpv, \"config-dir\", \"/my/path\"); // set config root\n      mpv_set_option_string(mpv, \"config\", \"yes\"); // enable config loading\n      (call mpv_initialize() _after_ this)\n - Idle mode is enabled, which means the playback core will enter idle mode\n   if there are no more files to play on the internal playlist, instead of\n   exiting. This is equivalent to the --idle option.\n - Disable parts of input handling.\n - Most of the different settings can be viewed with the command line player\n   by running \"mpv --show-profile=libmpv\".\n\n All this assumes that API users want a mpv instance that is strictly\n isolated from the command line player's configuration, user settings, and\n so on. You can re-enable disabled features by setting the appropriate\n options.\n\n The mpv command line parser is not available through this API, but you can\n set individual options with mpv_set_property(). Files for playback must be\n loaded with mpv_command() or others.\n\n Note that you should avoid doing concurrent accesses on the uninitialized\n client handle. (Whether concurrent access is definitely allowed or not has\n yet to be decided.)\n\n @return a new mpv client API handle. Returns NULL on error. Currently, this\n         can happen in the following situations:\n         - out of memory\n         - LC_NUMERIC is not set to \"C\" (see general remarks)"]
    pub fn mpv_create() -> *mut mpv_handle;
    #[doc = " Initialize an uninitialized mpv instance. If the mpv instance is already\n running, an error is returned.\n\n This function needs to be called to make full use of the client API if the\n client API handle was created with mpv_create().\n\n Only the following options are required to be set _before_ mpv_initialize():\n      - options which are only read at initialization time:\n        - config\n        - config-dir\n        - input-conf\n        - load-scripts\n        - script\n        - player-operation-mode\n        - input-app-events (OSX)\n      - all encoding mode options\n\n @return error code"]
    pub fn mpv_initialize(ctx: *mut mpv_handle) -> ::std::os::raw::c_int;
    #[doc = " Disconnect and destroy the mpv_handle. ctx will be deallocated with this\n API call.\n\n If the last mpv_handle is detached, the core player is destroyed. In\n addition, if there are only weak mpv_handles (such as created by\n mpv_create_weak_client() or internal scripts), these mpv_handles will\n be sent MPV_EVENT_SHUTDOWN. This function may block until these clients\n have responded to the shutdown event, and the core is finally destroyed."]
    pub fn mpv_destroy(ctx: *mut mpv_handle);
    #[doc = " Similar to mpv_destroy(), but brings the player and all clients down\n as well, and waits until all of them are destroyed. This function blocks. The\n advantage over mpv_destroy() is that while mpv_destroy() merely\n detaches the client handle from the player, this function quits the player,\n waits until all other clients are destroyed (i.e. all mpv_handles are\n detached), and also waits for the final termination of the player.\n\n Since mpv_destroy() is called somewhere on the way, it's not safe to\n call other functions concurrently on the same context.\n\n Since mpv client API version 1.29:\n  The first call on any mpv_handle will block until the core is destroyed.\n  This means it will wait until other mpv_handle have been destroyed. If you\n  want asynchronous destruction, just run the \"quit\" command, and then react\n  to the MPV_EVENT_SHUTDOWN event.\n  If another mpv_handle already called mpv_terminate_destroy(), this call will\n  not actually block. It will destroy the mpv_handle, and exit immediately,\n  while other mpv_handles might still be uninitializing.\n\n Before mpv client API version 1.29:\n  If this is called on a mpv_handle that was not created with mpv_create(),\n  this function will merely send a quit command and then call\n  mpv_destroy(), without waiting for the actual shutdown."]
    pub fn mpv_terminate_destroy(ctx: *mut mpv_handle);
    #[doc = " Create a new client handle connected to the same player core as ctx. This\n context has its own event queue, its own mpv_request_event() state, its own\n mpv_request_log_messages() state, its own set of observed properties, and\n its own state for asynchronous operations. Otherwise, everything is shared.\n\n This handle should be destroyed with mpv_destroy() if no longer\n needed. The core will live as long as there is at least 1 handle referencing\n it. Any handle can make the core quit, which will result in every handle\n receiving MPV_EVENT_SHUTDOWN.\n\n This function can not be called before the main handle was initialized with\n mpv_initialize(). The new handle is always initialized, unless ctx=NULL was\n passed.\n\n @param ctx Used to get the reference to the mpv core; handle-specific\n            settings and parameters are not used.\n            If NULL, this function behaves like mpv_create() (ignores name).\n @param name The client name. This will be returned by mpv_client_name(). If\n             the name is already in use, or contains non-alphanumeric\n             characters (other than '_'), the name is modified to fit.\n             If NULL, an arbitrary name is automatically chosen.\n @return a new handle, or NULL on error"]
    pub fn mpv_create_client(
        ctx: *mut mpv_handle,
        name: *const ::std::os::raw::c_char,
    ) -> *mut mpv_handle;
    #[doc = " This is the same as mpv_create_client(), but the created mpv_handle is\n treated as a weak reference. If all mpv_handles referencing a core are\n weak references, the core is automatically destroyed. (This still goes\n through normal uninit of course. Effectively, if the last non-weak mpv_handle\n is destroyed, then the weak mpv_handles receive MPV_EVENT_SHUTDOWN and are\n asked to terminate as well.)\n\n Note if you want to use this like refcounting: you have to be aware that\n mpv_terminate_destroy() _and_ mpv_destroy() for the last non-weak\n mpv_handle will block until all weak mpv_handles are destroyed."]
    pub fn mpv_create_weak_client(
        ctx: *mut mpv_handle,
        name: *const ::std::os::raw::c_char,
    ) -> *mut mpv_handle;
    #[doc = " Load a config file. This loads and parses the file, and sets every entry in\n the config file's default section as if mpv_set_option_string() is called.\n\n The filename should be an absolute path. If it isn't, the actual path used\n is unspecified. (Note: an absolute path starts with '/' on UNIX.) If the\n file wasn't found, MPV_ERROR_INVALID_PARAMETER is returned.\n\n If a fatal error happens when parsing a config file, MPV_ERROR_OPTION_ERROR\n is returned. Errors when setting options as well as other types or errors\n are ignored (even if options do not exist). You can still try to capture\n the resulting error messages with mpv_request_log_messages(). Note that it's\n possible that some options were successfully set even if any of these errors\n happen.\n\n @param filename absolute path to the config file on the local filesystem\n @return error code"]
    pub fn mpv_load_config_file(
        ctx: *mut mpv_handle,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    #[doc = " Return the internal time in microseconds. This has an arbitrary start offset,\n but will never wrap or go backwards.\n\n Note that this is always the real time, and doesn't necessarily have to do\n with playback time. For example, playback could go faster or slower due to\n playback speed, or due to playback being paused. Use the \"time-pos\" property\n instead to get the playback status.\n\n Unlike other libmpv APIs, this can be called at absolutely any time (even\n within wakeup callbacks), as long as the context is valid.\n\n Safe to be called from mpv render API threads."]
    pub fn mpv_get_time_us(ctx: *mut mpv_handle) -> i64;
    #[doc = " Frees any data referenced by the node. It doesn't free the node itself.\n Call this only if the mpv client API set the node. If you constructed the\n node yourself (manually), you have to free it yourself.\n\n If node->format is MPV_FORMAT_NONE, this call does nothing. Likewise, if\n the client API sets a node with this format, this function doesn't need to\n be called. (This is just a clarification that there's no danger of anything\n strange happening in these cases.)"]
    pub fn mpv_free_node_contents(node: *mut mpv_node);
    #[doc = " Set an option. Note that you can't normally set options during runtime. It\n works in uninitialized state (see mpv_create()), and in some cases in at\n runtime.\n\n Using a format other than MPV_FORMAT_NODE is equivalent to constructing a\n mpv_node with the given format and data, and passing the mpv_node to this\n function.\n\n Note: this is semi-deprecated. For most purposes, this is not needed anymore.\n       Starting with mpv version 0.21.0 (version 1.23) most options can be set\n       with mpv_set_property() (and related functions), and even before\n       mpv_initialize(). In some obscure corner cases, using this function\n       to set options might still be required (see\n       \"Inconsistencies between options and properties\" in the manpage). Once\n       these are resolved, the option setting functions might be fully\n       deprecated.\n\n @param name Option name. This is the same as on the mpv command line, but\n             without the leading \"--\".\n @param format see enum mpv_format.\n @param[in] data Option value (according to the format).\n @return error code"]
    pub fn mpv_set_option(
        ctx: *mut mpv_handle,
        name: *const ::std::os::raw::c_char,
        format: mpv_format,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
    #[doc = " Convenience function to set an option to a string value. This is like\n calling mpv_set_option() with MPV_FORMAT_STRING.\n\n @return error code"]
    pub fn mpv_set_option_string(
        ctx: *mut mpv_handle,
        name: *const ::std::os::raw::c_char,
        data: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    #[doc = " Send a command to the player. Commands are the same as those used in\n input.conf, except that this function takes parameters in a pre-split\n form.\n\n The commands and their parameters are documented in input.rst.\n\n Does not use OSD and string expansion by default (unlike mpv_command_string()\n and input.conf).\n\n @param[in] args NULL-terminated list of strings. Usually, the first item\n                 is the command, and the following items are arguments.\n @return error code"]
    pub fn mpv_command(
        ctx: *mut mpv_handle,
        args: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    #[doc = " Same as mpv_command(), but allows passing structured data in any format.\n In particular, calling mpv_command() is exactly like calling\n mpv_command_node() with the format set to MPV_FORMAT_NODE_ARRAY, and\n every arg passed in order as MPV_FORMAT_STRING.\n\n Does not use OSD and string expansion by default.\n\n The args argument can have one of the following formats:\n\n MPV_FORMAT_NODE_ARRAY:\n      Positional arguments. Each entry is an argument using an arbitrary\n      format (the format must be compatible to the used command). Usually,\n      the first item is the command name (as MPV_FORMAT_STRING). The order\n      of arguments is as documented in each command description.\n\n MPV_FORMAT_NODE_MAP:\n      Named arguments. This requires at least an entry with the key \"name\"\n      to be present, which must be a string, and contains the command name.\n      The special entry \"_flags\" is optional, and if present, must be an\n      array of strings, each being a command prefix to apply. All other\n      entries are interpreted as arguments. They must use the argument names\n      as documented in each command description. Some commands do not\n      support named arguments at all, and must use MPV_FORMAT_NODE_ARRAY.\n\n @param[in] args mpv_node with format set to one of the values documented\n                 above (see there for details)\n @param[out] result Optional, pass NULL if unused. If not NULL, and if the\n                    function succeeds, this is set to command-specific return\n                    data. You must call mpv_free_node_contents() to free it\n                    (again, only if the command actually succeeds).\n                    Not many commands actually use this at all.\n @return error code (the result parameter is not set on error)"]
    pub fn mpv_command_node(
        ctx: *mut mpv_handle,
        args: *mut mpv_node,
        result: *mut mpv_node,
    ) -> ::std::os::raw::c_int;
    #[doc = " This is essentially identical to mpv_command() but it also returns a result.\n\n Does not use OSD and string expansion by default.\n\n @param[in] args NULL-terminated list of strings. Usually, the first item\n                 is the command, and the following items are arguments.\n @param[out] result Optional, pass NULL if unused. If not NULL, and if the\n                    function succeeds, this is set to command-specific return\n                    data. You must call mpv_free_node_contents() to free it\n                    (again, only if the command actually succeeds).\n                    Not many commands actually use this at all.\n @return error code (the result parameter is not set on error)"]
    pub fn mpv_command_ret(
        ctx: *mut mpv_handle,
        args: *mut *const ::std::os::raw::c_char,
        result: *mut mpv_node,
    ) -> ::std::os::raw::c_int;
    #[doc = " Same as mpv_command, but use input.conf parsing for splitting arguments.\n This is slightly simpler, but also more error prone, since arguments may\n need quoting/escaping.\n\n This also has OSD and string expansion enabled by default."]
    pub fn mpv_command_string(
        ctx: *mut mpv_handle,
        args: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    #[doc = " Same as mpv_command, but run the command asynchronously.\n\n Commands are executed asynchronously. You will receive a\n MPV_EVENT_COMMAND_REPLY event. This event will also have an\n error code set if running the command failed. For commands that\n return data, the data is put into mpv_event_command.result.\n\n The only case when you do not receive an event is when the function call\n itself fails. This happens only if parsing the command itself (or otherwise\n validating it) fails, i.e. the return code of the API call is not 0 or\n positive.\n\n Safe to be called from mpv render API threads.\n\n @param reply_userdata the value mpv_event.reply_userdata of the reply will\n                       be set to (see section about asynchronous calls)\n @param args NULL-terminated list of strings (see mpv_command())\n @return error code (if parsing or queuing the command fails)"]
    pub fn mpv_command_async(
        ctx: *mut mpv_handle,
        reply_userdata: u64,
        args: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    #[doc = " Same as mpv_command_node(), but run it asynchronously. Basically, this\n function is to mpv_command_node() what mpv_command_async() is to\n mpv_command().\n\n See mpv_command_async() for details.\n\n Safe to be called from mpv render API threads.\n\n @param reply_userdata the value mpv_event.reply_userdata of the reply will\n                       be set to (see section about asynchronous calls)\n @param args as in mpv_command_node()\n @return error code (if parsing or queuing the command fails)"]
    pub fn mpv_command_node_async(
        ctx: *mut mpv_handle,
        reply_userdata: u64,
        args: *mut mpv_node,
    ) -> ::std::os::raw::c_int;
    #[doc = " Signal to all async requests with the matching ID to abort. This affects\n the following API calls:\n\n      mpv_command_async\n      mpv_command_node_async\n\n All of these functions take a reply_userdata parameter. This API function\n tells all requests with the matching reply_userdata value to try to return\n as soon as possible. If there are multiple requests with matching ID, it\n aborts all of them.\n\n This API function is mostly asynchronous itself. It will not wait until the\n command is aborted. Instead, the command will terminate as usual, but with\n some work not done. How this is signaled depends on the specific command (for\n example, the \"subprocess\" command will indicate it by \"killed_by_us\" set to\n true in the result). How long it takes also depends on the situation. The\n aborting process is completely asynchronous.\n\n Not all commands may support this functionality. In this case, this function\n will have no effect. The same is true if the request using the passed\n reply_userdata has already terminated, has not been started yet, or was\n never in use at all.\n\n You have to be careful of race conditions: the time during which the abort\n request will be effective is _after_ e.g. mpv_command_async() has returned,\n and before the command has signaled completion with MPV_EVENT_COMMAND_REPLY.\n\n @param reply_userdata ID of the request to be aborted (see above)"]
    pub fn mpv_abort_async_command(ctx: *mut mpv_handle, reply_userdata: u64);
    #[doc = " Set a property to a given value. Properties are essentially variables which\n can be queried or set at runtime. For example, writing to the pause property\n will actually pause or unpause playback.\n\n If the format doesn't match with the internal format of the property, access\n usually will fail with MPV_ERROR_PROPERTY_FORMAT. In some cases, the data\n is automatically converted and access succeeds. For example, MPV_FORMAT_INT64\n is always converted to MPV_FORMAT_DOUBLE, and access using MPV_FORMAT_STRING\n usually invokes a string parser. The same happens when calling this function\n with MPV_FORMAT_NODE: the underlying format may be converted to another\n type if possible.\n\n Using a format other than MPV_FORMAT_NODE is equivalent to constructing a\n mpv_node with the given format and data, and passing the mpv_node to this\n function. (Before API version 1.21, this was different.)\n\n Note: starting with mpv 0.21.0 (client API version 1.23), this can be used to\n       set options in general. It even can be used before mpv_initialize()\n       has been called. If called before mpv_initialize(), setting properties\n       not backed by options will result in MPV_ERROR_PROPERTY_UNAVAILABLE.\n       In some cases, properties and options still conflict. In these cases,\n       mpv_set_property() accesses the options before mpv_initialize(), and\n       the properties after mpv_initialize(). These conflicts will be removed\n       in mpv 0.23.0. See mpv_set_option() for further remarks.\n\n @param name The property name. See input.rst for a list of properties.\n @param format see enum mpv_format.\n @param[in] data Option value.\n @return error code"]
    pub fn mpv_set_property(
        ctx: *mut mpv_handle,
        name: *const ::std::os::raw::c_char,
        format: mpv_format,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
    #[doc = " Convenience function to set a property to a string value.\n\n This is like calling mpv_set_property() with MPV_FORMAT_STRING."]
    pub fn mpv_set_property_string(
        ctx: *mut mpv_handle,
        name: *const ::std::os::raw::c_char,
        data: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    #[doc = " Set a property asynchronously. You will receive the result of the operation\n as MPV_EVENT_SET_PROPERTY_REPLY event. The mpv_event.error field will contain\n the result status of the operation. Otherwise, this function is similar to\n mpv_set_property().\n\n Safe to be called from mpv render API threads.\n\n @param reply_userdata see section about asynchronous calls\n @param name The property name.\n @param format see enum mpv_format.\n @param[in] data Option value. The value will be copied by the function. It\n                 will never be modified by the client API.\n @return error code if sending the request failed"]
    pub fn mpv_set_property_async(
        ctx: *mut mpv_handle,
        reply_userdata: u64,
        name: *const ::std::os::raw::c_char,
        format: mpv_format,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
    #[doc = " Read the value of the given property.\n\n If the format doesn't match with the internal format of the property, access\n usually will fail with MPV_ERROR_PROPERTY_FORMAT. In some cases, the data\n is automatically converted and access succeeds. For example, MPV_FORMAT_INT64\n is always converted to MPV_FORMAT_DOUBLE, and access using MPV_FORMAT_STRING\n usually invokes a string formatter.\n\n @param name The property name.\n @param format see enum mpv_format.\n @param[out] data Pointer to the variable holding the option value. On\n                  success, the variable will be set to a copy of the option\n                  value. For formats that require dynamic memory allocation,\n                  you can free the value with mpv_free() (strings) or\n                  mpv_free_node_contents() (MPV_FORMAT_NODE).\n @return error code"]
    pub fn mpv_get_property(
        ctx: *mut mpv_handle,
        name: *const ::std::os::raw::c_char,
        format: mpv_format,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
    #[doc = " Return the value of the property with the given name as string. This is\n equivalent to mpv_get_property() with MPV_FORMAT_STRING.\n\n See MPV_FORMAT_STRING for character encoding issues.\n\n On error, NULL is returned. Use mpv_get_property() if you want fine-grained\n error reporting.\n\n @param name The property name.\n @return Property value, or NULL if the property can't be retrieved. Free\n         the string with mpv_free()."]
    pub fn mpv_get_property_string(
        ctx: *mut mpv_handle,
        name: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    #[doc = " Return the property as \"OSD\" formatted string. This is the same as\n mpv_get_property_string, but using MPV_FORMAT_OSD_STRING.\n\n @return Property value, or NULL if the property can't be retrieved. Free\n         the string with mpv_free()."]
    pub fn mpv_get_property_osd_string(
        ctx: *mut mpv_handle,
        name: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    #[doc = " Get a property asynchronously. You will receive the result of the operation\n as well as the property data with the MPV_EVENT_GET_PROPERTY_REPLY event.\n You should check the mpv_event.error field on the reply event.\n\n Safe to be called from mpv render API threads.\n\n @param reply_userdata see section about asynchronous calls\n @param name The property name.\n @param format see enum mpv_format.\n @return error code if sending the request failed"]
    pub fn mpv_get_property_async(
        ctx: *mut mpv_handle,
        reply_userdata: u64,
        name: *const ::std::os::raw::c_char,
        format: mpv_format,
    ) -> ::std::os::raw::c_int;
    #[doc = " Get a notification whenever the given property changes. You will receive\n updates as MPV_EVENT_PROPERTY_CHANGE. Note that this is not very precise:\n for some properties, it may not send updates even if the property changed.\n This depends on the property, and it's a valid feature request to ask for\n better update handling of a specific property. (For some properties, like\n ``clock``, which shows the wall clock, this mechanism doesn't make too\n much sense anyway.)\n\n Property changes are coalesced: the change events are returned only once the\n event queue becomes empty (e.g. mpv_wait_event() would block or return\n MPV_EVENT_NONE), and then only one event per changed property is returned.\n\n You always get an initial change notification. This is meant to initialize\n the user's state to the current value of the property.\n\n Normally, change events are sent only if the property value changes according\n to the requested format. mpv_event_property will contain the property value\n as data member.\n\n Warning: if a property is unavailable or retrieving it caused an error,\n          MPV_FORMAT_NONE will be set in mpv_event_property, even if the\n          format parameter was set to a different value. In this case, the\n          mpv_event_property.data field is invalid.\n\n If the property is observed with the format parameter set to MPV_FORMAT_NONE,\n you get low-level notifications whether the property _may_ have changed, and\n the data member in mpv_event_property will be unset. With this mode, you\n will have to determine yourself whether the property really changed. On the\n other hand, this mechanism can be faster and uses less resources.\n\n Observing a property that doesn't exist is allowed. (Although it may still\n cause some sporadic change events.)\n\n Keep in mind that you will get change notifications even if you change a\n property yourself. Try to avoid endless feedback loops, which could happen\n if you react to the change notifications triggered by your own change.\n\n Only the mpv_handle on which this was called will receive the property\n change events, or can unobserve them.\n\n Safe to be called from mpv render API threads.\n\n @param reply_userdata This will be used for the mpv_event.reply_userdata\n                       field for the received MPV_EVENT_PROPERTY_CHANGE\n                       events. (Also see section about asynchronous calls,\n                       although this function is somewhat different from\n                       actual asynchronous calls.)\n                       If you have no use for this, pass 0.\n                       Also see mpv_unobserve_property().\n @param name The property name.\n @param format see enum mpv_format. Can be MPV_FORMAT_NONE to omit values\n               from the change events.\n @return error code (usually fails only on OOM or unsupported format)"]
    pub fn mpv_observe_property(
        mpv: *mut mpv_handle,
        reply_userdata: u64,
        name: *const ::std::os::raw::c_char,
        format: mpv_format,
    ) -> ::std::os::raw::c_int;
    #[doc = " Undo mpv_observe_property(). This will remove all observed properties for\n which the given number was passed as reply_userdata to mpv_observe_property.\n\n Safe to be called from mpv render API threads.\n\n @param registered_reply_userdata ID that was passed to mpv_observe_property\n @return negative value is an error code, >=0 is number of removed properties\n         on success (includes the case when 0 were removed)"]
    pub fn mpv_unobserve_property(
        mpv: *mut mpv_handle,
        registered_reply_userdata: u64,
    ) -> ::std::os::raw::c_int;
    #[doc = " Return a string describing the event. For unknown events, NULL is returned.\n\n Note that all events actually returned by the API will also yield a non-NULL\n string with this function.\n\n @param event event ID, see see enum mpv_event_id\n @return A static string giving a short symbolic name of the event. It\n         consists of lower-case alphanumeric characters and can include \"-\"\n         characters. This string is suitable for use in e.g. scripting\n         interfaces.\n         The string is completely static, i.e. doesn't need to be deallocated,\n         and is valid forever."]
    pub fn mpv_event_name(event: mpv_event_id) -> *const ::std::os::raw::c_char;
    #[doc = " Convert the given src event to a mpv_node, and set *dst to the result. *dst\n is set to a MPV_FORMAT_NODE_MAP, with fields for corresponding mpv_event and\n mpv_event.data/mpv_event_* fields.\n\n The exact details are not completely documented out of laziness. A start\n is located in the \"Events\" section of the manpage.\n\n *dst may point to newly allocated memory, or pointers in mpv_event. You must\n copy the entire mpv_node if you want to reference it after mpv_event becomes\n invalid (such as making a new mpv_wait_event() call, or destroying the\n mpv_handle from which it was returned). Call mpv_free_node_contents() to free\n any memory allocations made by this API function.\n\n Safe to be called from mpv render API threads.\n\n @param dst Target. This is not read and fully overwritten. Must be released\n            with mpv_free_node_contents(). Do not write to pointers returned\n            by it. (On error, this may be left as an empty node.)\n @param src The source event. Not modified (it's not const due to the author's\n            prejudice of the C version of const).\n @return error code (MPV_ERROR_NOMEM only, if at all)"]
    pub fn mpv_event_to_node(dst: *mut mpv_node, src: *mut mpv_event) -> ::std::os::raw::c_int;
    #[doc = " Enable or disable the given event.\n\n Some events are enabled by default. Some events can't be disabled.\n\n (Informational note: currently, all events are enabled by default, except\n  MPV_EVENT_TICK.)\n\n Safe to be called from mpv render API threads.\n\n @param event See enum mpv_event_id.\n @param enable 1 to enable receiving this event, 0 to disable it.\n @return error code"]
    pub fn mpv_request_event(
        ctx: *mut mpv_handle,
        event: mpv_event_id,
        enable: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    #[doc = " Enable or disable receiving of log messages. These are the messages the\n command line player prints to the terminal. This call sets the minimum\n required log level for a message to be received with MPV_EVENT_LOG_MESSAGE.\n\n @param min_level Minimal log level as string. Valid log levels:\n                      no fatal error warn info v debug trace\n                  The value \"no\" disables all messages. This is the default.\n                  An exception is the value \"terminal-default\", which uses the\n                  log level as set by the \"--msg-level\" option. This works\n                  even if the terminal is disabled. (Since API version 1.19.)\n                  Also see mpv_log_level.\n @return error code"]
    pub fn mpv_request_log_messages(
        ctx: *mut mpv_handle,
        min_level: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    #[doc = " Wait for the next event, or until the timeout expires, or if another thread\n makes a call to mpv_wakeup(). Passing 0 as timeout will never wait, and\n is suitable for polling.\n\n The internal event queue has a limited size (per client handle). If you\n don't empty the event queue quickly enough with mpv_wait_event(), it will\n overflow and silently discard further events. If this happens, making\n asynchronous requests will fail as well (with MPV_ERROR_EVENT_QUEUE_FULL).\n\n Only one thread is allowed to call this on the same mpv_handle at a time.\n The API won't complain if more than one thread calls this, but it will cause\n race conditions in the client when accessing the shared mpv_event struct.\n Note that most other API functions are not restricted by this, and no API\n function internally calls mpv_wait_event(). Additionally, concurrent calls\n to different mpv_handles are always safe.\n\n As long as the timeout is 0, this is safe to be called from mpv render API\n threads.\n\n @param timeout Timeout in seconds, after which the function returns even if\n                no event was received. A MPV_EVENT_NONE is returned on\n                timeout. A value of 0 will disable waiting. Negative values\n                will wait with an infinite timeout.\n @return A struct containing the event ID and other data. The pointer (and\n         fields in the struct) stay valid until the next mpv_wait_event()\n         call, or until the mpv_handle is destroyed. You must not write to\n         the struct, and all memory referenced by it will be automatically\n         released by the API on the next mpv_wait_event() call, or when the\n         context is destroyed. The return value is never NULL."]
    pub fn mpv_wait_event(ctx: *mut mpv_handle, timeout: f64) -> *mut mpv_event;
    #[doc = " Interrupt the current mpv_wait_event() call. This will wake up the thread\n currently waiting in mpv_wait_event(). If no thread is waiting, the next\n mpv_wait_event() call will return immediately (this is to avoid lost\n wakeups).\n\n mpv_wait_event() will receive a MPV_EVENT_NONE if it's woken up due to\n this call. But note that this dummy event might be skipped if there are\n already other events queued. All what counts is that the waiting thread\n is woken up at all.\n\n Safe to be called from mpv render API threads."]
    pub fn mpv_wakeup(ctx: *mut mpv_handle);
    #[doc = " Set a custom function that should be called when there are new events. Use\n this if blocking in mpv_wait_event() to wait for new events is not feasible.\n\n Keep in mind that the callback will be called from foreign threads. You\n must not make any assumptions of the environment, and you must return as\n soon as possible (i.e. no long blocking waits). Exiting the callback through\n any other means than a normal return is forbidden (no throwing exceptions,\n no longjmp() calls). You must not change any local thread state (such as\n the C floating point environment).\n\n You are not allowed to call any client API functions inside of the callback.\n In particular, you should not do any processing in the callback, but wake up\n another thread that does all the work. The callback is meant strictly for\n notification only, and is called from arbitrary core parts of the player,\n that make no considerations for reentrant API use or allowing the callee to\n spend a lot of time doing other things. Keep in mind that it's also possible\n that the callback is called from a thread while a mpv API function is called\n (i.e. it can be reentrant).\n\n In general, the client API expects you to call mpv_wait_event() to receive\n notifications, and the wakeup callback is merely a helper utility to make\n this easier in certain situations. Note that it's possible that there's\n only one wakeup callback invocation for multiple events. You should call\n mpv_wait_event() with no timeout until MPV_EVENT_NONE is reached, at which\n point the event queue is empty.\n\n If you actually want to do processing in a callback, spawn a thread that\n does nothing but call mpv_wait_event() in a loop and dispatches the result\n to a callback.\n\n Only one wakeup callback can be set.\n\n @param cb function that should be called if a wakeup is required\n @param d arbitrary userdata passed to cb"]
    pub fn mpv_set_wakeup_callback(
        ctx: *mut mpv_handle,
        cb: ::std::option::Option<unsafe extern "C" fn(d: *mut ::std::os::raw::c_void)>,
        d: *mut ::std::os::raw::c_void,
    );
    #[doc = " Block until all asynchronous requests are done. This affects functions like\n mpv_command_async(), which return immediately and return their result as\n events.\n\n This is a helper, and somewhat equivalent to calling mpv_wait_event() in a\n loop until all known asynchronous requests have sent their reply as event,\n except that the event queue is not emptied.\n\n In case you called mpv_suspend() before, this will also forcibly reset the\n suspend counter of the given handle."]
    pub fn mpv_wait_async_requests(ctx: *mut mpv_handle);
    #[doc = " A hook is like a synchronous event that blocks the player. You register\n a hook handler with this function. You will get an event, which you need\n to handle, and once things are ready, you can let the player continue with\n mpv_hook_continue().\n\n Currently, hooks can't be removed explicitly. But they will be implicitly\n removed if the mpv_handle it was registered with is destroyed. This also\n continues the hook if it was being handled by the destroyed mpv_handle (but\n this should be avoided, as it might mess up order of hook execution).\n\n Hook handlers are ordered globally by priority and order of registration.\n Handlers for the same hook with same priority are invoked in order of\n registration (the handler registered first is run first). Handlers with\n lower priority are run first (which seems backward).\n\n See the \"Hooks\" section in the manpage to see which hooks are currently\n defined.\n\n Some hooks might be reentrant (so you get multiple MPV_EVENT_HOOK for the\n same hook). If this can happen for a specific hook type, it will be\n explicitly documented in the manpage.\n\n Only the mpv_handle on which this was called will receive the hook events,\n or can \"continue\" them.\n\n @param reply_userdata This will be used for the mpv_event.reply_userdata\n                       field for the received MPV_EVENT_HOOK events.\n                       If you have no use for this, pass 0.\n @param name The hook name. This should be one of the documented names. But\n             if the name is unknown, the hook event will simply be never\n             raised.\n @param priority See remarks above. Use 0 as a neutral default.\n @return error code (usually fails only on OOM)"]
    pub fn mpv_hook_add(
        ctx: *mut mpv_handle,
        reply_userdata: u64,
        name: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    #[doc = " Respond to a MPV_EVENT_HOOK event. You must call this after you have handled\n the event. There is no way to \"cancel\" or \"stop\" the hook.\n\n Calling this will will typically unblock the player for whatever the hook\n is responsible for (e.g. for the \"on_load\" hook it lets it continue\n playback).\n\n It is explicitly undefined behavior to call this more than once for each\n MPV_EVENT_HOOK, to pass an incorrect ID, or to call this on a mpv_handle\n different from the one that registered the handler and received the event.\n\n @param id This must be the value of the mpv_event_hook.id field for the\n           corresponding MPV_EVENT_HOOK.\n @return error code"]
    pub fn mpv_hook_continue(ctx: *mut mpv_handle, id: u64) -> ::std::os::raw::c_int;
    #[doc = " Return a UNIX file descriptor referring to the read end of a pipe. This\n pipe can be used to wake up a poll() based processing loop. The purpose of\n this function is very similar to mpv_set_wakeup_callback(), and provides\n a primitive mechanism to handle coordinating a foreign event loop and the\n libmpv event loop. The pipe is non-blocking. It's closed when the mpv_handle\n is destroyed. This function always returns the same value (on success).\n\n This is in fact implemented using the same underlying code as for\n mpv_set_wakeup_callback() (though they don't conflict), and it is as if each\n callback invocation writes a single 0 byte to the pipe. When the pipe\n becomes readable, the code calling poll() (or select()) on the pipe should\n read all contents of the pipe and then call mpv_wait_event(c, 0) until\n no new events are returned. The pipe contents do not matter and can just\n be discarded. There is not necessarily one byte per readable event in the\n pipe. For example, the pipes are non-blocking, and mpv won't block if the\n pipe is full. Pipes are normally limited to 4096 bytes, so if there are\n more than 4096 events, the number of readable bytes can not equal the number\n of events queued. Also, it's possible that mpv does not write to the pipe\n once it's guaranteed that the client was already signaled. See the example\n below how to do it correctly.\n\n Example:\n\n  int pipefd = mpv_get_wakeup_pipe(mpv);\n  if (pipefd < 0)\n      error();\n  while (1) {\n      struct pollfd pfds[1] = {\n          { .fd = pipefd, .events = POLLIN },\n      };\n      // Wait until there are possibly new mpv events.\n      poll(pfds, 1, -1);\n      if (pfds[0].revents & POLLIN) {\n          // Empty the pipe. Doing this before calling mpv_wait_event()\n          // ensures that no wakeups are missed. It's not so important to\n          // make sure the pipe is really empty (it will just cause some\n          // additional wakeups in unlikely corner cases).\n          char unused[256];\n          read(pipefd, unused, sizeof(unused));\n          while (1) {\n              mpv_event *ev = mpv_wait_event(mpv, 0);\n              // If MPV_EVENT_NONE is received, the event queue is empty.\n              if (ev->event_id == MPV_EVENT_NONE)\n                  break;\n              // Process the event.\n              ...\n          }\n      }\n  }\n\n @deprecated this function will be removed in the future. If you need this\n             functionality, use mpv_set_wakeup_callback(), create a pipe\n             manually, and call write() on your pipe in the callback.\n\n @return A UNIX FD of the read end of the wakeup pipe, or -1 on error.\n         On MS Windows/MinGW, this will always return -1."]
    pub fn mpv_get_wakeup_pipe(ctx: *mut mpv_handle) -> ::std::os::raw::c_int;
    #[doc = " Initialize the renderer state. Depending on the backend used, this will\n access the underlying GPU API and initialize its own objects.\n\n You must free the context with mpv_render_context_free(). Not doing so before\n the mpv core is destroyed may result in memory leaks or crashes.\n\n Currently, only at most 1 context can exists per mpv core (it represents the\n main video output).\n\n You should pass the following parameters:\n  - MPV_RENDER_PARAM_API_TYPE to select the underlying backend/GPU API.\n  - Backend-specific init parameter, like MPV_RENDER_PARAM_OPENGL_INIT_PARAMS.\n  - Setting MPV_RENDER_PARAM_ADVANCED_CONTROL and following its rules is\n    strongly recommended.\n  - If you want to use hwdec, possibly hwdec interop resources.\n\n @param res set to the context (on success) or NULL (on failure). The value\n            is never read and always overwritten.\n @param mpv handle used to get the core (the mpv_render_context won't depend\n            on this specific handle, only the core referenced by it)\n @param params an array of parameters, terminated by type==0. It's left\n               unspecified what happens with unknown parameters. At least\n               MPV_RENDER_PARAM_API_TYPE is required, and most backends will\n               require another backend-specific parameter.\n @return error code, including but not limited to:\n      MPV_ERROR_UNSUPPORTED: the OpenGL version is not supported\n                             (or required extensions are missing)\n      MPV_ERROR_NOT_IMPLEMENTED: an unknown API type was provided, or\n                                 support for the requested API was not\n                                 built in the used libmpv binary.\n      MPV_ERROR_INVALID_PARAMETER: at least one of the provided parameters was\n                                   not valid."]
    pub fn mpv_render_context_create(
        res: *mut *mut mpv_render_context,
        mpv: *mut mpv_handle,
        params: *mut mpv_render_param,
    ) -> ::std::os::raw::c_int;
    #[doc = " Attempt to change a single parameter. Not all backends and parameter types\n support all kinds of changes.\n\n @param ctx a valid render context\n @param param the parameter type and data that should be set\n @return error code. If a parameter could actually be changed, this returns\n         success, otherwise an error code depending on the parameter type\n         and situation."]
    pub fn mpv_render_context_set_parameter(
        ctx: *mut mpv_render_context,
        param: mpv_render_param,
    ) -> ::std::os::raw::c_int;
    #[doc = " Retrieve information from the render context. This is NOT a counterpart to\n mpv_render_context_set_parameter(), because you generally can't read\n parameters set with it, and this function is not meant for this purpose.\n Instead, this is for communicating information from the renderer back to the\n user. See mpv_render_param_type; entries which support this function\n explicitly mention it, and for other entries you can assume it will fail.\n\n You pass param with param.type set and param.data pointing to a variable\n of the required data type. The function will then overwrite that variable\n with the returned value (at least on success).\n\n @param ctx a valid render context\n @param param the parameter type and data that should be retrieved\n @return error code. If a parameter could actually be retrieved, this returns\n         success, otherwise an error code depending on the parameter type\n         and situation. MPV_ERROR_NOT_IMPLEMENTED is used for unknown\n         param.type, or if retrieving it is not supported."]
    pub fn mpv_render_context_get_info(
        ctx: *mut mpv_render_context,
        param: mpv_render_param,
    ) -> ::std::os::raw::c_int;
    #[doc = " Set the callback that notifies you when a new video frame is available, or\n if the video display configuration somehow changed and requires a redraw.\n Similar to mpv_set_wakeup_callback(), you must not call any mpv API from\n the callback, and all the other listed restrictions apply (such as not\n exiting the callback by throwing exceptions).\n\n This can be called from any thread, except from an update callback. In case\n of the OpenGL backend, no OpenGL state or API is accessed.\n\n Calling this will raise an update callback immediately.\n\n @param callback callback(callback_ctx) is called if the frame should be\n                 redrawn\n @param callback_ctx opaque argument to the callback"]
    pub fn mpv_render_context_set_update_callback(
        ctx: *mut mpv_render_context,
        callback: mpv_render_update_fn,
        callback_ctx: *mut ::std::os::raw::c_void,
    );
    #[doc = " The API user is supposed to call this when the update callback was invoked\n (like all mpv_render_* functions, this has to happen on the render thread,\n and _not_ from the update callback itself).\n\n This is optional if MPV_RENDER_PARAM_ADVANCED_CONTROL was not set (default).\n Otherwise, it's a hard requirement that this is called after each update\n callback. If multiple update callback happened, and the function could not\n be called sooner, it's OK to call it once after the last callback.\n\n If an update callback happens during or after this function, the function\n must be called again at the soonest possible time.\n\n If MPV_RENDER_PARAM_ADVANCED_CONTROL was set, this will do additional work\n such as allocating textures for the video decoder.\n\n @return a bitset of mpv_render_update_flag values (i.e. multiple flags are\n         combined with bitwise or). Typically, this will tell the API user\n         what should happen next. E.g. if the MPV_RENDER_UPDATE_FRAME flag is\n         set, mpv_render_context_render() should be called. If flags unknown\n         to the API user are set, or if the return value is 0, nothing needs\n         to be done."]
    pub fn mpv_render_context_update(ctx: *mut mpv_render_context) -> u64;
    #[doc = " Render video.\n\n Typically renders the video to a target surface provided via mpv_render_param\n (the details depend on the backend in use). Options like \"panscan\" are\n applied to determine which part of the video should be visible and how the\n video should be scaled. You can change these options at runtime by using the\n mpv property API.\n\n The renderer will reconfigure itself every time the target surface\n configuration (such as size) is changed.\n\n This function implicitly pulls a video frame from the internal queue and\n renders it. If no new frame is available, the previous frame is redrawn.\n The update callback set with mpv_render_context_set_update_callback()\n notifies you when a new frame was added. The details potentially depend on\n the backends and the provided parameters.\n\n Generally, libmpv will invoke your update callback some time before the video\n frame should be shown, and then lets this function block until the supposed\n display time. This will limit your rendering to video FPS. You can prevent\n this by setting the \"video-timing-offset\" global option to 0. (This applies\n only to \"audio\" video sync mode.)\n\n You should pass the following parameters:\n  - Backend-specific target object, such as MPV_RENDER_PARAM_OPENGL_FBO.\n  - Possibly transformations, such as MPV_RENDER_PARAM_FLIP_Y.\n\n @param ctx a valid render context\n @param params an array of parameters, terminated by type==0. Which parameters\n               are required depends on the backend. It's left unspecified what\n               happens with unknown parameters.\n @return error code"]
    pub fn mpv_render_context_render(
        ctx: *mut mpv_render_context,
        params: *mut mpv_render_param,
    ) -> ::std::os::raw::c_int;
    #[doc = " Tell the renderer that a frame was flipped at the given time. This is\n optional, but can help the player to achieve better timing.\n\n Note that calling this at least once informs libmpv that you will use this\n function. If you use it inconsistently, expect bad video playback.\n\n If this is called while no video is initialized, it is ignored.\n\n @param ctx a valid render context"]
    pub fn mpv_render_context_report_swap(ctx: *mut mpv_render_context);
    #[doc = " Destroy the mpv renderer state.\n\n If video is still active (e.g. a file playing), video will be disabled\n forcefully.\n\n @param ctx a valid render context. After this function returns, this is not\n            a valid pointer anymore. NULL is also allowed and does nothing."]
    pub fn mpv_render_context_free(ctx: *mut mpv_render_context);
}
